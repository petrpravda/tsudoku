import {ENGINE} from "./engine";
import {handleHintOne} from "../../reducer/SudokuGridReducer";
import {Explanation} from "./explanation";

const ALL_NUMBERS_SET = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]);

/**
 * Returns union from Sudoku puzzle given numbers and user entered values.
 *
 * @param knownNumbers Sudoku puzzle quiz given numbers
 * @param userEntered user entered numbers
 */
function getEnteredAndGivenNumbers(knownNumbers: Array<number | undefined>, userEntered: Array<number | undefined>): Array<number | undefined> {
    let result = Array.from(Array(81), () => undefined) as Array<number | undefined>;
    for (let index = 0; index < 81; index++) {
        result[index] = knownNumbers[index] ?? userEntered[index];
    }
    return result;
}

/**
 * Returns all possible candidate hints.
 *
 * @param knownNumbers Sudoku puzzle quiz given numbers
 * @param userEntered user entered numbers
 */
export function fillInCandidates(knownNumbers: Array<number | undefined>, userEntered: Array<number | undefined>): Array<Set<number>> {
    let enteredAndGivenNumbers = getEnteredAndGivenNumbers(knownNumbers, userEntered);
    let candidates = new Candidates(enteredAndGivenNumbers);
    return candidates.sets;
}

/**
 * Returns textual game descriptor of current state of the game.
 *
 * @param known Sudoku puzzle quiz given numbers
 * @param userEntered user entered numbers
 */
export const getGameDescriptor = (known: Array<number | undefined>, userEntered: Array<number | undefined>): string => {
    return range(0, 81)
        .map(index => known[index] ?? userEntered[index])
        .map(num => num === undefined ? '.' : num.toString())
        .join('');
}

/**
 * Returns textual candidates descriptor.
 *
 * @param candidates user candidates (either entered by a user or autogenerated for the user)
 */
export const getCandidatesDescriptor = (candidates: Array<Set<number> | undefined>): string => {
    return range(0, 81)
        .map(index => candidates[index])
        .map(set => set !== undefined ? Array.from(set).join('') : '')
        .join(',');
}

/**
 * Class taking care of eligible candidate hints
 */
export class Candidates {
    public rows = Array.from(Array(9), () => new Set()) as Array<Set<number>>;
    public columns = Array.from(Array(9), () => new Set()) as Array<Set<number>>;
    public squares = Array.from(Array(9), () => new Set()) as Array<Set<number>>;
    public nRows = Array.from(Array(9), () => new Set()) as Array<Set<number>>;
    public nColumns = Array.from(Array(9), () => new Set()) as Array<Set<number>>;
    public nSquares = Array.from(Array(9), () => new Set()) as Array<Set<number>>;
    public sets = Array.from(Array(81), () => new Set()) as Array<Set<number>>;

    constructor(enteredAndGivenNumbers: Array<number | undefined>) {
        this.fillInNumbers(enteredAndGivenNumbers);
    }

    /**
     * Evaluates all candidate hints upon Sudoku grid numbers
     *
     * @param enteredAndGivenNumbers current state of the Sudoku game
     */
    private fillInNumbers(enteredAndGivenNumbers: Array<number | undefined>) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (let [row, column, index, sRow, sColumn, sIndex] of iterateBoard()) {
            let value = enteredAndGivenNumbers[index];
            if (value !== undefined) {
                this.rows[row].add(value);
                this.columns[column].add(value);
                this.squares[sIndex].add(value);
            }
        }

        for (let index = 0; index < 9; index++) {
            this.nRows[index] = flipNumbers(this.rows[index]);
            this.nColumns[index] = flipNumbers(this.columns[index]);
            this.nSquares[index] = flipNumbers(this.squares[index]);
        }

        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        for (let [row, column, index, sRow, sColumn, sIndex] of iterateBoard()) {
            let value = enteredAndGivenNumbers[index];
            let candidates = undefined;
            if (value === undefined) {
                candidates = [...this.nRows[row]]
                    .filter(x => this.nColumns[column].has(x))
                    .filter(x => this.nSquares[sIndex].has(x));
            }
            this.sets[index] = new Set(candidates);
        }
    }
}

/**
 * Iterator over Sudoku board. It returns list of indices for
 * * row
 * * column
 * * ordinal number of Sudoku cell
 * * square row
 * * square column
 * * ordinal number of square
 */
function* iterateBoard(): IterableIterator<[number, number, number, number, number, number]> {
    for (let row = 0; row < 9; row++) {
        for (let column = 0; column < 9; column++) {
            let index = row * 9 + column;
            let sRow = Math.floor(row / 3);
            let sColumn = Math.floor(column / 3);
            let sIndex = sRow * 3 + sColumn;
            yield [row, column, index, sRow, sColumn, sIndex];
        }
    }
}

/**
 * Returns inverted set of number candidates. That means it returns numbers which are
 * not in values input parameter.
 *
 * @param values candidates
 */
export function flipNumbers(values: Set<number>): Set<number> {
    return new Set([...ALL_NUMBERS_SET].filter(x => !values.has(x)));
}

/**
 * It creates iterator for a square which a cell is in. It generates indices of ordinal Sudoku cells.
 *
 * @param index ordinal number of Sudoku cell
 */
export function* iterateSquareByIndex(index: number): IterableIterator<number> {
    let row = Math.floor(index / 9);
    let column = index - row * 9;
    let sRow = Math.floor(row / 3);
    let sColumn = Math.floor(column / 3);
    for (let y = 0; y < 3; y++) {
        for (let x = 0; x < 3; x++) {
            yield (sRow * 3 + y) * 9 + (sColumn * 3 + x);
        }
    }
}

/**
 * Range utility function
 *
 * @param start range inclusive start
 * @param end range exclusive end
 */
export const range = (start: number, end: number) => [...Array(end - start)].map((_, i) => start + i);

/**
 * Iterator over Sudoku board. It returns an object of row and column pair.
 * r contains row
 * c contains column
 * It finds use in JSX templates.
 */
export function* nineByNineCoords(): IterableIterator<{r: number, c: number}> {
    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            yield {r, c};
        }
    }
}

/**
 * Asks Sudoku solver engine for a hint for one step.
 *
 * @param game descriptor (all Sudoku game quiz numbers + user entered numbers)
 * @param candidates user entered candidate hints
 * @param solverCandidates solver candidates from previous invocations of hintone command
 */
export async function askForHint(game: string, candidates: string, solverCandidates: string | undefined): Promise<[Explanation, string] | undefined> {
    let cmd = `hintone ${game} ${candidates}${solverCandidates !== undefined ? ' '+solverCandidates : ''}`;
    let response = await ENGINE.sendMsg(cmd);
    let hintOneResponseArgs = response.split('|');
    return handleHintOne(hintOneResponseArgs);
}
